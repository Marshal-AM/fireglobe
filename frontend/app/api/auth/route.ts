import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId, email, walletAddress } = body;

    if (!userId) {
      return NextResponse.json(
        { error: 'userId is required' },
        { status: 400 }
      );
    }

    // Check if user already exists by email or wallet address
    let existingUser = null;
    
    if (email) {
      const { data } = await supabase
        .from('users')
        .select('*')
        .eq('email', email)
        .single();
      
      existingUser = data;
    }

    if (!existingUser && walletAddress) {
      const { data } = await supabase
        .from('users')
        .select('*')
        .eq('wallet_address', walletAddress)
        .single();
      
      existingUser = data;
    }

    // If user exists, check if we need to update wallet address
    if (existingUser) {
      // If user has no wallet address but we have one from Privy, update it
      if (!existingUser.wallet_address && walletAddress) {
        const { data: updatedUser, error: updateError } = await supabase
          .from('users')
          .update({ wallet_address: walletAddress })
          .eq('user_id', existingUser.user_id)
          .select()
          .single();

        if (updateError) {
          console.error('Failed to update wallet address:', updateError);
          // Continue with existing user data even if update fails
        } else {
          // Use updated user data
          existingUser = updatedUser;
        }
      }

      return NextResponse.json({
        success: true,
        user_id: existingUser.user_id,
        access_token: existingUser.access_token,
        email: existingUser.email,
        name: existingUser.name,
        wallet_address: existingUser.wallet_address,
        created_at: existingUser.created_at,
        is_new: false,
      });
    }

    // Create new user (access_token will be auto-generated by database)
    // Only store wallet_address, leave email and name null for now
    const { data: newUser, error } = await supabase
      .from('users')
      .insert([
        {
          wallet_address: walletAddress || null,
          // email and name will be null - to be filled later
        },
      ])
      .select()
      .single();

    if (error) {
      console.error('Supabase error:', error);
      return NextResponse.json(
        { error: 'Failed to create user', details: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      user_id: newUser.user_id,
      access_token: newUser.access_token,
      email: newUser.email,
      name: newUser.name,
      wallet_address: newUser.wallet_address,
      created_at: newUser.created_at,
      is_new: true,
      message: 'User created successfully. Save your access_token!',
    });
  } catch (error) {
    console.error('Auth error:', error);
    return NextResponse.json(
      { error: 'Internal server error', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

// GET endpoint to verify access token
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const accessToken = searchParams.get('access_token');

    if (!accessToken) {
      return NextResponse.json(
        { error: 'access_token is required' },
        { status: 400 }
      );
    }

    const { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('access_token', accessToken)
      .single();

    if (error || !user) {
      return NextResponse.json(
        { error: 'Invalid access token' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      wallet_address: user.wallet_address,
      created_at: user.created_at,
    });
  } catch (error) {
    console.error('Verify error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

